<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üíº Cashflow System</title>
<style>
  body { font-family: Arial, sans-serif; background: #f0f2f5; margin:0; padding:0; }
  .container { width: 95%; max-width:1200px; margin:20px auto; }
  h1,h2,h3,h4 { margin:5px 0; }
  button { cursor:pointer; transition: background 0.2s; }
  .tabs { display:flex; margin:20px 0; gap:5px; flex-wrap:wrap; }
  .tablink { padding:10px 20px; border:none; border-radius:6px; background:#ddd; color:#333; font-weight:bold; }
  .tablink.active { background:#3498db; color:#fff; }
  .tablink:hover:not(.active) { background:#bbb; }
  .tabcontent { display:none; }
  .cards { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:20px; }
  .card { background:white; flex:1 1 150px; padding:15px; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); transition: transform 0.1s, box-shadow 0.1s; }
  .card:hover { transform: translateY(-2px); box-shadow:0 4px 8px rgba(0,0,0,0.15); }
  .form-container { background:white; padding:15px; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); margin-bottom:20px; }
  table { width:100%; border-collapse:collapse; background:white; }
  th,td { padding:8px; border:1px solid #ccc; text-align:center; }
  #logoutBtn { background:#e74c3c; color:white; border:none; padding:6px 12px; border-radius:6px; }
  #profitSection { display:none; }
</style>
</head>
<body>
<div class="container">

<!-- LOGIN -->
<div id="loginSection">
  <h1>Login</h1>
  <form id="loginForm">
    <label>Email:<input type="email" id="loginEmail" required></label><br><br>
    <label>Password:<input type="password" id="loginPassword" required></label><br><br>
    <button type="submit">Login</button>
  </form>
</div>

<!-- APP -->
<div id="appSection" style="display:none;">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <h1 style="font-size:28px;">üíº Cashflow System</h1>
    <button id="logoutBtn" onclick="logout()">Logout</button>
  </div>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tablink" onclick="openTab('dashboard', this)">Dashboard</button>
    <button class="tablink" onclick="openTab('cashflow', this)">Cash-in / Cash-out</button>
    <button class="tablink" onclick="openTab('rebalance', this)">Rebalance</button>
    <button class="tablink" id="ownerSettingsTab" onclick="openTab('ownerSettings', this)" style="display:none;">Owner Settings</button>
  </div>

  <!-- DASHBOARD -->
  <div id="dashboard" class="tabcontent">
    <div class="cards">
      <div class="card"><h3>Cash-on-hand</h3><p id="dashCash">‚Ç±0</p></div>
      <div class="card"><h3>GCash Balance</h3><p id="dashGcash">‚Ç±0</p></div>
      <div class="card" id="profitSection"><h3>Total Profit</h3><p id="dashProfit">‚Ç±0</p></div>
      <div class="card"><h3>Total Balance</h3><p id="dashTotal">‚Ç±0</p></div>
    </div>
    <div class="cards">
      <div class="card"><h4>Daily Total</h4><p id="dailyTotal">‚Ç±0</p></div>
      <div class="card"><h4>Weekly Total</h4><p id="weeklyTotal">‚Ç±0</p></div>
      <div class="card"><h4>Monthly Total</h4><p id="monthlyTotal">‚Ç±0</p></div>
      <div class="card"><h4>Yearly Total</h4><p id="yearlyTotal">‚Ç±0</p></div>
    </div>
  </div>

  <!-- CASHFLOW -->
  <div id="cashflow" class="tabcontent">
    <div class="form-container">
      <h2>Add Cash-in / Cash-out</h2>
      <form id="transactionForm">
        <label>Type:
          <select id="type" required>
            <option value="cashin">Cash-in</option>
            <option value="cashout">Cash-out</option>
            <option value="loading">Loading</option>
            <option value="billspayment">Bills Payment</option>
          </select>
        </label><br><br>
        <label>Amount:<input type="number" id="amount" required min="1" placeholder="‚Ç±0"></label><br><br>
        
        <label id="billsFeeLabel" style="display:none;">
  GCash Bill Fee:
  <input type="number" id="billsGcashFee" min="0" value="0">
</label><br><br>

        <label>Payment Method:
          <select id="method" required>
            <option value="cash">Cash</option>
            <option value="gcash">GCash</option>
          </select>
        </label><br><br>
        <label>
          Fee goes to:
            <select id="feeDestination">
            <option value="cash" selected>Cash (default)</option>
            <option value="gcash">GCash</option>
          </select>
        </label><br><br>
        <label>Notes:<input type="text" id="notes" placeholder="Optional"></label><br><br>
        <button type="submit">Add Transaction</button>
      </form>
    </div>
    <h2>Transaction History</h2>
    <table id="transactionTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Type</th>
          <th>Amount</th>
          <th>Method</th>
          <th>GCash Fee</th>  <!-- NEW -->
          <th>Fee</th>
          <th>Fee ‚Üí</th>
          <th>Profit</th>
          <th>Notes</th>
          <th>By</th>
          <th id="actionHeader" style="display:none;">Action</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- REBALANCE -->
  <div id="rebalance" class="tabcontent">
    <div class="form-container">
      <h2>Rebalance Cash / GCash</h2>
      <form id="rebalanceForm">
        <label>From:
          <select id="rebalanceFrom" required>
            <option value="cash">Cash-on-hand</option>
            <option value="gcash">GCash</option>
          </select>
        </label><br><br>
        <label>To:
          <select id="rebalanceTo" required>
            <option value="cash">Cash-on-hand</option>
            <option value="gcash">GCash</option>
          </select>
        </label><br><br>
        <label>Amount:<input type="number" id="rebalanceAmount" required min="1"></label><br><br>
        <label>Notes:<input type="text" id="rebalanceNotes" placeholder="Optional"></label><br><br>
        <button type="submit">Transfer</button>
      </form>
    </div>
  </div>

  <!-- OWNER SETTINGS -->
<div id="ownerSettings" class="tabcontent">
  <h2>Owner Settings</h2>

  <!-- ‚úÖ OWNER BALANCE ANCHOR -->
  <h3>Owner Balance Anchor (Admin Only)</h3>
  <p style="font-size:13px;color:#555;">
    Set the real physical balances ONCE to anchor audit calculations.
  </p>

  <input id="knownCash" type="number" placeholder="Current Cash">
  <input id="knownGcash" type="number" placeholder="Current GCash">
  <br><br>
  <button onclick="setKnownBalance()">SET CURRENT BALANCE</button>

  <hr>

  <!-- MANUAL BALANCE (OVERRIDE) -->
  <form id="manualBalanceForm">
    <label>Cash Balance</label>
    <input type="number" id="manualCash" step="0.01" required><br><br>

    <label>GCash Balance</label>
    <input type="number" id="manualGCash" step="0.01" required><br><br>

    <button type="submit">Update Balances</button>
  </form>

  <!-- ‚ö†Ô∏è DANGER ZONE -->
  <div style="border:2px solid #e74c3c; padding:15px; border-radius:10px; margin-top:20px;">
    <h3 style="color:#e74c3c;">‚ö†Ô∏è Danger Zone</h3>
    <p>This will permanently reset all balances and transactions.</p>
    <button id="clearResetBtn"
      onclick="confirmClear()"
      style="background:#e74c3c;color:white;border:none;padding:10px 16px;border-radius:8px;">
      RESET SYSTEM
    </button>
  </div>
</div>


</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-analytics-compat.js"></script>

<script>
  let deletingTx = false;

const firebaseConfig = {
  apiKey: "AIzaSyDF5BuG7cfbLhyIWJkgzKVNmXH9KtB4_AQ",
  authDomain: "cashflowsystem-e8597.firebaseapp.com",
  projectId: "cashflowsystem-e8597",
  storageBucket: "cashflowsystem-e8597.firebasestorage.app",
  messagingSenderId: "282993339590",
  appId: "1:282993339590:web:a9aa3ed3d21341195fbbc7",
  measurementId: "G-8NG4M1874C"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const balancesRef = db.collection("balances").doc("main");
let currentUserRole = "";

// ----- LOGIN -----
async function login(email,password){
  try{
    const userCredential = await auth.signInWithEmailAndPassword(email,password);
    const uid = userCredential.user.uid;
    const userDoc = await db.collection("users").doc(uid).get();
    if(!userDoc.exists){ alert("No role assigned!"); auth.signOut(); return; }
    currentUserRole = userDoc.data().role;
    document.getElementById("loginSection").style.display="none";
    document.getElementById("appSection").style.display="block";
    applyRoleUI(currentUserRole);
    setupDashboardRealtime();
    initializeTabs();
  }catch(e){ alert(e.message); }
}

// ----- ROLE UI -----
function applyRoleUI(role) {
  const cashInOut = document.getElementById("cashflow");
  const rebalance = document.getElementById("rebalance");
  const profitSection = document.getElementById("profitSection");
  const ownerTab = document.getElementById("ownerSettingsTab");
  const clearBtn = document.getElementById("clearResetBtn");
  const actionHeader = document.getElementById("actionHeader");

  // üîí HIDE ALL FIRST
  cashInOut.style.display = "none";
  rebalance.style.display = "none";
  profitSection.style.display = "none";
  ownerTab.style.display = "none";
  clearBtn.style.display = "none";
  if (actionHeader) actionHeader.style.display = "none";

  // üë§ STAFF
  if (role === "staff") {
    cashInOut.style.display = "block";
    profitSection.style.display = "none";
  }

  // üëë OWNER
  if (role === "owner") {
    cashInOut.style.display = "block";
    rebalance.style.display = "block";
    profitSection.style.display = "block";
    ownerTab.style.display = "inline-block";
    clearBtn.style.display = "inline-block";

     // ‚úÖ FIX: SHOW ACTION HEADER
    const actionHeader = document.getElementById("actionHeader");
    if (actionHeader) {
      actionHeader.style.display = "table-cell";
    }
  }
}


// ----- LOGIN FORM -----
document.getElementById("loginForm").addEventListener("submit", e=>{
  e.preventDefault();
  login(document.getElementById("loginEmail").value, document.getElementById("loginPassword").value);
});

// ----- TABS -----
function openTab(tab, btn){
  document.querySelectorAll(".tabcontent").forEach(t=>t.style.display="none");
  document.getElementById(tab).style.display="block";
  document.querySelectorAll(".tablink").forEach(b=>b.classList.remove("active"));
  btn.classList.add("active");
  localStorage.setItem("activeTab", tab);
}
function initializeTabs(){
  document.querySelectorAll(".tabcontent").forEach(t=>t.style.display="none");
  const lastTab = localStorage.getItem("activeTab") || "dashboard";
  document.getElementById(lastTab).style.display="block";
  document.querySelectorAll(".tablink").forEach(b=>{
    b.classList.remove("active");
    if(b.getAttribute("onclick")?.includes(lastTab)) b.classList.add("active");
  });
}

// ----- DASHBOARD REALTIME -----
function setupDashboardRealtime(){

  // ‚úÖ BOTH STAFF + OWNER CAN SEE BALANCES
  balancesRef.onSnapshot(snap=>{
    if(!snap.exists) return;
    const data = snap.data();

    document.getElementById("dashCash").innerText = `‚Ç±${data.cash||0}`;
    document.getElementById("dashGcash").innerText = `‚Ç±${data.gcash||0}`;
    document.getElementById("dashTotal").innerText =
      `‚Ç±${(data.cash||0)+(data.gcash||0)}`;

    // üîí OWNER ONLY
    if (currentUserRole === "owner") {
      document.getElementById("dashProfit").innerText = `‚Ç±${data.profit||0}`;
    }
  });

  // üîí üîí üîí PROFIT TOTALS = OWNER ONLY üîí üîí üîí
  if (currentUserRole !== "owner") return;

  db.collection("transactions").onSnapshot(snap=>{
    let daily=0,weekly=0,monthly=0,yearly=0;
    const now=new Date();
    const sevenDaysAgo=new Date(); sevenDaysAgo.setDate(now.getDate()-7);

    snap.forEach(doc=>{
      const tx=doc.data();
      if(tx.type==="rebalance") return;

      const txDate=new Date(tx.date);

      if(txDate.toDateString()===now.toDateString()) daily+=tx.profit||0;
      if(txDate>=sevenDaysAgo) weekly+=tx.profit||0;
      if(txDate.getMonth()===now.getMonth()) monthly+=tx.profit||0;
      if(txDate.getFullYear()===now.getFullYear()) yearly+=tx.profit||0;
    });

    document.getElementById("dailyTotal").innerText=`‚Ç±${daily}`;
    document.getElementById("weeklyTotal").innerText=`‚Ç±${weekly}`;
    document.getElementById("monthlyTotal").innerText=`‚Ç±${monthly}`;
    document.getElementById("yearlyTotal").innerText=`‚Ç±${yearly}`;
  });
}



// ----- FEE CALC -----
function calculateFee(amount){
  if(amount<=100) return 5;
  if(amount<=500) return 10;
  if(amount<=1000) return 20;
  return 20 + Math.floor((amount-1000)/1000)*20;
}


  // ----- SHOW / HIDE BILL PAYMENT FEE -----
document.getElementById("type").addEventListener("change", () => {
  const type = document.getElementById("type").value;
  const isBills = type === "billspayment";

  document.getElementById("billsFeeLabel").style.display = isBills ? "block" : "none";

  // üîí FORCE PAYMENT METHOD TO CASH FOR BILLS
  if (isBills) {
    document.getElementById("method").value = "cash";
    document.getElementById("method").disabled = true;
  } else {
    document.getElementById("method").disabled = false;
  }
});


  
// ----- TRANSACTION FORM -----
document.getElementById("transactionForm").addEventListener("submit", async e => {
  e.preventDefault();

  try {
    const type = document.getElementById("type").value.toLowerCase();
    const method = document.getElementById("method").value;
    const notes = document.getElementById("notes").value || "";
    const amount = parseFloat(document.getElementById("amount").value);
  
    // üö´ FORCE BILLS PAYMENT = CASH ONLY
    if (type === "billspayment" && method !== "cash") {
      alert("Bills payment must be CASH only.");
      return;
    }

    
    let fee = 0, profit = 0;
    let cashChange = 0, gcashChange = 0;
    let gcashFee = 0; // <-- MOVE TO OUTER SCOPE
    let feeDestination = document.getElementById("feeDestination")?.value || "cash";

    // CASH IN
    if (type === "cashin") {
      fee = calculateFee(amount);
      profit = fee;

        // base transaction
      cashChange = amount;     // customer gives cash
      gcashChange = -amount;  // you send gcash


      // CASH OUT
    } else if (type === "cashout") {
      fee = calculateFee(amount);
       profit = fee;

      // you give CASH
        cashChange = -amount;    // you give cash
      // customer sends GCASH
        gcashChange = amount;   // customer sends gcash (BASE only)


    
    
    } else if (type === "loading") {
  // ----- GCash Load Rules -----
  gcashFee = amount <= 98 ? 1 : 2;

  // Determine customer fee based on total (amount + gcashFee)
  let customerFee = 5; // default for small amounts
  const totalAmount = amount + gcashFee;

  if (totalAmount >= 100 && totalAmount <= 500) {
    customerFee = 10;
  } else if (totalAmount > 500 && totalAmount <= 1000) {
    customerFee = 20;
  } else if (totalAmount > 1000) {
    customerFee = 20 + Math.floor((totalAmount - 1000)/1000)*20;
  }

  fee = customerFee; // displayed as ‚ÄúFee‚Äù in table
  profit = customerFee - gcashFee;

  // Apply cash/gcash changes depending on payment method
  if (method === "cash") {
    cashChange = amount + customerFee;       // customer paid in cash
    gcashChange = -(amount + gcashFee);      // deducted from GCash
  } else if (method === "gcash") {
    cashChange = 0;                           // no cash involved
    gcashChange = -(amount + gcashFee - customerFee); // net GCash change
  }

  // Store gcashFee separately in the transaction table
  // optional: if you want to display it






    } else if (type === "billspayment") {
      const billsFeeInput = document.getElementById("billsGcashFee");
      const billsFee = billsFeeInput ? parseFloat(billsFeeInput.value) || 0 : 0;
      fee = billsFee;
      profit = billsFee;

      gcashChange = -(amount + billsFee);
      cashChange = amount;
      gcashFee = billsFee; // <-- explicitly store it
    }

    

                  // ----- BALANCE SAFETY CHECK -----
const balanceSnap = await balancesRef.get();
if (!balanceSnap.exists) {
  alert("Balances not initialized!");
  return;
}

const currentCash = balanceSnap.data().cash || 0;
const currentGcash = balanceSnap.data().gcash || 0;

// simulate result
const newCash = currentCash + cashChange;
const newGcash = currentGcash + gcashChange;

// ‚ùå BLOCK NEGATIVE BALANCE
if (newCash < 0) {
  alert("‚ùå Transaction denied: Not enough CASH balance.");
  return;
}

if (newGcash < 0) {
  alert("‚ùå Transaction denied: Not enough GCASH balance.");
  return;
}

   // ===== APPLY FEE DESTINATION (CASHIN / CASHOUT ONLY) =====
if (fee > 0 && (type === "cashin" || type === "cashout")) {
  if (feeDestination === "cash") {
    cashChange += fee;
  } else if (feeDestination === "gcash") {
    gcashChange += fee;
  }
}



    // ===============================
// ROLE-BASED SAVE (CRITICAL FIX)
// ===============================

// üëâ STAFF: TRANSACTION ONLY (NO BALANCE TOUCH)
if (currentUserRole === "staff") {

  await db.collection("transactions").add({
    date: new Date().toISOString(),
    type,
    amount,
    method,
    gcashFee,
    fee,
    profit,
    feeDestination,
    feeAppliedToCash: feeDestination === "cash",
    notes,
    role: currentUserRole
  });

  document.getElementById("transactionForm").reset();
  alert("‚úÖ Transaction saved");
  return;
}

// üëâ OWNER: TRANSACTION + BALANCE UPDATE
if (currentUserRole === "owner") {

  await balancesRef.update({
    cash: firebase.firestore.FieldValue.increment(cashChange),
    gcash: firebase.firestore.FieldValue.increment(gcashChange),
    profit: firebase.firestore.FieldValue.increment(profit)
  });

  await db.collection("transactions").add({
    date: new Date().toISOString(),
    type,
    amount,
    method,
    gcashFee,
    fee,
    profit,
    feeDestination,
    feeAppliedToCash: feeDestination === "cash",
    notes,
    role: currentUserRole
  });

  document.getElementById("transactionForm").reset();
  alert("‚úÖ Transaction + balances updated");
}


  } catch (err) {
    alert("Transaction failed: " + err.message);
    console.error(err);
  }
});





  

  
    // ===============================
// OPTION C v2: FIX OLD FEES (SMART)
// ===============================
async function fixOldCashFees() {
  if (currentUserRole !== "owner") {
    alert("‚ùå Owner only.");
    return;
  }

  const ok = confirm(
    "This will add MISSING fees to CASH for old cashin/cashout.\n\nRUN ONLY ONCE.\nContinue?"
  );
  if (!ok) return;

  const confirm2 = prompt("Type FIX to proceed:");
  if (confirm2 !== "FIX") return;

  const snap = await db.collection("transactions").get();

  let totalCashAdded = 0;
  let fixed = 0;

  for (const doc of snap.docs) {
    const tx = doc.data();

    if (tx.type !== "cashin" && tx.type !== "cashout") continue;
    if (!tx.fee || tx.fee <= 0) continue;
    if (tx.feeAppliedToCash === true) continue;

    await balancesRef.update({
      cash: firebase.firestore.FieldValue.increment(tx.fee),
      openingCash,
      openingGcash
    });

    await doc.ref.update({
      feeAppliedToCash: true,
      feeDestination: "cash"
    });

    totalCashAdded += tx.fee;
    fixed++;
  }

  alert(
    `‚úÖ FIX COMPLETE\n\n` +
    `Transactions fixed: ${fixed}\n` +
    `Cash added: ‚Ç±${totalCashAdded}`
  );
}


      async function computeOpeningBalance() {
  if (currentUserRole !== "owner") return;

  const balSnap = await balancesRef.get();
  const balances = balSnap.data();

  let deltaCash = 0;
  let deltaGcash = 0;

  const snap = await db.collection("transactions").get();

  snap.forEach(doc => {
    const tx = doc.data();

    if (tx.type === "cashin") {
      deltaCash += tx.amount;
      deltaGcash -= tx.amount;
    }

    if (tx.type === "cashout") {
      deltaCash -= tx.amount;
      deltaGcash += tx.amount;
    }

    if (tx.type === "loading") {
      if (tx.method === "cash") {
        deltaCash += tx.amount + tx.fee;
        deltaGcash -= tx.amount + (tx.gcashFee || 0);
      } else {
        deltaGcash -= tx.amount + (tx.gcashFee || 0) - tx.fee;
      }
    }

    if (tx.type === "billspayment") {
      deltaCash += tx.amount;
      deltaGcash -= tx.amount + tx.fee;
    }

    if (tx.fee > 0 && (tx.type === "cashin" || tx.type === "cashout")) {
      if ((tx.feeDestination || "cash") === "cash") {
        deltaCash += tx.fee;
      } else {
        deltaGcash += tx.fee;
      }
    }
  });

  const openingCash = balances.cash - deltaCash;
  const openingGcash = balances.gcash - deltaGcash;

  alert(
    "üìå COMPUTED OPENING BALANCE\n\n" +
    `Cash: ‚Ç±${openingCash}\n` +
    `GCash: ‚Ç±${openingGcash}\n\n` +
    "Verify physically before saving."
  );
}











  
          // ----------AUDIT----------
  async function runDailyAudit() {
  if (currentUserRole !== "owner") return;

  const balSnap = await balancesRef.get();
  if (!balSnap.exists) return;

  const balances = balSnap.data();

  const anchorSnap = await db
    .collection("balance_anchor")
    .doc("current")
    .get();

    if (!anchorSnap.exists) {
      alert("‚ùå No balance anchor set.");
      return;
    }

    let expectedCash = anchorSnap.data().cash;
    let expectedGcash = anchorSnap.data().gcash;
    const anchorTime = anchorSnap.data().timestamp;
    
  const snap = await db
  .collection("transactions")
  .where("timestamp", ">", anchorTime)
  .orderBy("timestamp")
  .get();


  snap.forEach(doc => {
    const tx = doc.data();

    if (tx.type === "cashin") {
      expectedCash += tx.amount;
      expectedGcash -= tx.amount;
    }

    if (tx.type === "cashout") {
      expectedCash -= tx.amount;
      expectedGcash += tx.amount;
    }

    if (tx.type === "loading") {
      if (tx.method === "cash") {
        expectedCash += tx.amount + tx.fee;
        expectedGcash -= tx.amount + (tx.gcashFee || 0);
      } else {
        expectedGcash -= tx.amount + (tx.gcashFee || 0) - tx.fee;
      }
    }

    if (tx.type === "billspayment") {
      expectedCash += tx.amount;
      expectedGcash -= tx.amount + tx.fee;
    }

    if (tx.fee > 0 && (tx.type === "cashin" || tx.type === "cashout")) {
      if ((tx.feeDestination || "cash") === "cash") {
        expectedCash += tx.fee;
      } else {
        expectedGcash += tx.fee;
      }
    }
  });

  if (
    expectedCash !== balances.cash ||
    expectedGcash !== balances.gcash
  ) {
    alert(
      "‚ö†Ô∏è DAILY AUDIT WARNING\n\n" +
      `Expected Cash: ‚Ç±${expectedCash}\nActual Cash: ‚Ç±${balances.cash}\n\n` +
      `Expected GCash: ‚Ç±${expectedGcash}\nActual GCash: ‚Ç±${balances.gcash}`
    );
  } else {
    console.log("‚úÖ Daily audit passed");
  }
}


  // ===============================
// OWNER BALANCE ANCHOR (FIRESTORE)
// ===============================
async function setKnownBalance() {
  if (currentUserRole !== "owner") {
    alert("Owner only");
    return;
  }

  const cash = Number(document.getElementById("knownCash").value);
  const gcash = Number(document.getElementById("knownGcash").value);

  if (isNaN(cash) || isNaN(gcash) || cash < 0 || gcash < 0) {
    alert("‚ùå Invalid balance values");
    return;
  }

  try {
    await db.collection("balance_anchor").doc("current").set({
      cash: cash,
      gcash: gcash,
      setBy: auth.currentUser.uid,
      role: currentUserRole,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });

    alert("‚úÖ Balance anchor saved (Firestore).");
  } catch (err) {
    console.error(err);
    alert("‚ùå Failed to save balance anchor.");
  }
}

  
  
  // ===============================
// OWNER ONLY: DELETE TRANSACTION
// ===============================
async function deleteTransaction(txId) {
  if (deletingTx) {
    alert("‚ö†Ô∏è Delete already in progress.");
    return;
  }
  deletingTx = true;

  try {
    if (!confirm("‚ö†Ô∏è Delete this transaction? Balances will be reversed.")) return;

    const reason = prompt("Enter DELETE REASON (required):");
    if (!reason || reason.trim().length < 5) {
      alert("‚ùå Delete reason is required (min 5 chars).");
      return;
    }

    const confirm2 = prompt("Type DELETE to confirm:");
    if (confirm2 !== "DELETE") return;

    const txRef = db.collection("transactions").doc(txId);
    const txSnap = await txRef.get();
    if (!txSnap.exists) {
      alert("Transaction not found.");
      return;
    }

    const tx = txSnap.data();

    let cashReverse = 0;
    let gcashReverse = 0;
    let profitReverse = 0;

    switch (tx.type) {
      case "cashin":
        cashReverse = -tx.amount;
        gcashReverse = tx.amount;
        profitReverse = -tx.profit;
        break;

      case "cashout":
        cashReverse = tx.amount;
        gcashReverse = -tx.amount;
        profitReverse = -tx.profit;
        break;

      default:
        alert("Cannot delete this transaction.");
        return;
    }

    const balSnap = await balancesRef.get();
    const b = balSnap.data();

    if ((b.cash + cashReverse) < 0 || (b.gcash + gcashReverse) < 0) {
      alert("‚ùå Cannot delete: balance would go negative.");
      return;
    }

    // reverse fee
    if (tx.fee > 0) {
      if ((tx.feeDestination || "cash") === "cash") {
        cashReverse -= tx.fee;
      } else {
        gcashReverse -= tx.fee;
      }
    }

    await balancesRef.update({
      cash: firebase.firestore.FieldValue.increment(cashReverse),
      gcash: firebase.firestore.FieldValue.increment(gcashReverse),
      profit: firebase.firestore.FieldValue.increment(profitReverse)
    });

    await db.collection("audit_logs").add({
      action: "DELETE_TRANSACTION",
      transactionId: txId,
      deletedType: tx.type,
      deletedAmount: tx.amount,
      deletedFee: tx.fee,
      deletedProfit: tx.profit,
      reason: reason.trim(),
      deletedBy: currentUserRole,
      deletedByUid: auth.currentUser.uid,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });

    await txRef.delete();
    alert("‚úÖ Transaction deleted. Audit log saved.");

  } catch (err) {
    console.error(err);
    alert("‚ùå Delete failed: " + err.message);

  } finally {
    deletingTx = false; // üîì ALWAYS RESET
  }
}

  
 // ----- TRANSACTION TABLE -----
function setupTransactionsListener(){
  const tbody = document.querySelector("#transactionTable tbody");

  db.collection("transactions")
    .where("date", "!=", null)
    .orderBy("date", "desc")
    .onSnapshot(snap => {
      tbody.innerHTML = "";

      snap.forEach(doc => {
        const tx = doc.data();

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${new Date(tx.date).toLocaleString()}</td>
          <td>${tx.type}</td>
          <td>‚Ç±${tx.amount}</td>
          <td>${tx.method}</td>
          <td>‚Ç±${tx.gcashFee || 0}</td>
          <td>‚Ç±${tx.fee || 0}</td>
          <td>${tx.feeDestination || "cash"}</td>
          <td>${currentUserRole === "owner" ? "‚Ç±"+tx.profit : "-"}</td>
          <td>${tx.notes || ""}</td>
          <td>${tx.role}</td>
        `;
        tbody.appendChild(tr);
      });
    }, err => {
      console.error("Transaction listener error:", err.message);
    });
}


// call this after login



// ----- REBALANCE -----
document.getElementById("rebalanceForm").addEventListener("submit", async e=>{
  e.preventDefault();
  const from=document.getElementById("rebalanceFrom").value;
  const to=document.getElementById("rebalanceTo").value;
  const amount=parseFloat(document.getElementById("rebalanceAmount").value);
  const notes=document.getElementById("rebalanceNotes").value||"";
  if(from===to){ alert("Cannot transfer to same account!"); return; }
  if(from==="cash"&&to==="gcash") await balancesRef.update({cash:firebase.firestore.FieldValue.increment(-amount),gcash:firebase.firestore.FieldValue.increment(amount)});
  if(from==="gcash"&&to==="cash") await balancesRef.update({gcash:firebase.firestore.FieldValue.increment(-amount),cash:firebase.firestore.FieldValue.increment(amount)});
  await db.collection("transactions").add({date:new Date().toISOString(),type:"rebalance",amount,method:`${from}‚Üí${to}`,fee:0,profit:0,notes,role:currentUserRole});
  document.getElementById("rebalanceForm").reset();
});

// ----- MANUAL BALANCE -----
document.getElementById("manualBalanceForm").addEventListener("submit", async e=>{
  e.preventDefault();
  const cash=parseFloat(document.getElementById("manualCash").value)||0;
  const gcash=parseFloat(document.getElementById("manualGCash").value)||0;
  await balancesRef.set({cash,gcash,profit:0,initialized:true});
  alert("Balances updated!");
});

// ----- RESET SYSTEM -----
function confirmClear(){
  if(!confirm("‚ö†Ô∏è This will RESET ALL DATA. Are you sure?")) return;
  const confirm2 = prompt("Type RESET to confirm:");
  if(confirm2!=="RESET"){ alert("Reset cancelled."); return; }
  clearAllData();
}
async function clearAllData(){
  const txSnap = await db.collection("transactions").get();
  txSnap.forEach(doc=>doc.ref.delete());
  await balancesRef.set({cash:0,gcash:0,profit:0,initialized:true});
  alert("All data cleared!");
}

// ----- LOGOUT -----
function logout(){
  auth.signOut();
  document.getElementById("appSection").style.display="none";
  document.getElementById("loginSection").style.display="block";
  document.getElementById("loginEmail").value="";
  document.getElementById("loginPassword").value="";
}

// ----- AUTH STATE -----
firebase.auth().onAuthStateChanged(async user => {
  if (!user) return;

  try {
    // üîÑ FORCE REFRESH TOKEN (IMPORTANT FOR OWNER CLAIMS)
    await user.getIdToken(true);

    const userDoc = await db.collection("users").doc(user.uid).get();
    if (!userDoc.exists) {
      alert("No role assigned.");
      await auth.signOut();
      return;
    }

    currentUserRole = userDoc.data().role;

    // SHOW APP
    document.getElementById("loginSection").style.display = "none";
    document.getElementById("appSection").style.display = "block";

    // APPLY ROLE UI
    applyRoleUI(currentUserRole);

    // ‚úÖ START LISTENERS ONLY AFTER ROLE IS CONFIRMED
    // ALWAYS allowed
setupTransactionsListener();
initializeTabs();

// OWNER ONLY FEATURES
if (currentUserRole === "owner") {
  setupDashboardRealtime(); // listens to balances
  runDailyAudit();         // audit uses balances + logs
}


  } catch (err) {
    console.error("Auth init error:", err);
    alert("Initialization failed. Please reload.");
  }
});

</script>
</body>
</html>
